\documentclass[runningheads,orivec]{llncs} 
\usepackage{amsmath,amssymb,mathtools}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{booktabs}
% Figures (message-flow)
\usepackage{tikz}
\usetikzlibrary{calc,arrows.meta,positioning,calc}
\setlist[enumerate]{leftmargin=*,itemsep=0.25em}
% Algorithm boxes
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[section]{placeins}
\usepackage{float} % for H when absolutely needed
% dark PDF theme
\usepackage{xcolor}
\pagecolor[rgb]{0,0,0} %black
\color[rgb]{0.5,0.5,0.5} %grey

\newcommand{\prot}{\textsf{QuanTEEum}}
\newcommand{\sid}{\mathsf{sid}}
\newcommand{\Att}{\mathsf{AttestDelete}}
\newcommand{\RA}{\mathsf{RA}}
\newcommand{\FROST}{\textsf{FROST}}
\newcommand{\cFROST}{\FROST{}~\cite{komlo2020frost}}
\newcommand{\oss}{\textsf{OSS}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}
\title{QuanTEEum: Quantum Cryptography via TEEs}
% \author{[Redacted for review]}
% \institute{[Redacted for review]}
\author{Shoaib Ahmed}
\institute{Cycles Protocol SA}
\maketitle

\begin{abstract}
One-shot signatures (OSS) have emerged as a versatile abstraction underpinning proposed blockchain applications including deterministic finality, quantum money, and ceremony-free SNARK parameters. Existing OSS constructions rely on quantum hardware that will not be widely available soon. Naïve emulations using a single trusted execution environment (TEE) inherit brittle unclonability requirements and concentrate integrity risk in one enclave. We present \prot{}, an honest-minority distributed protocol that realizes certified deletion and one-shot signing by running threshold signing entirely \emph{inside} independent TEEs. In \prot{}, $n$ enclaves run a threshold DKG, produce exactly one threshold signature on a designated statement, and each emits a remote-attestation (RA) binding an in-enclave deletion event. Security is \emph{additive}: every independent deletion attestation strictly raises the minimum attack cost, mitigating single-point TEE failures. We formalize certified deletion and one-shot signing in a remote-attestation model and show the attestation mechanism is pluggable: (a) conventional TEE RA, (b) cryptoeconomic attestations via escrowed collateral, and (c) future quantum instantiations, yielding a clean upgrade path. We sketch applications to single-shot block finality, quantum-money-flavored tokens, and de-facto ceremony-free CRS generation, and discuss liveness, freshness, and rollback subtleties.
\end{abstract}

\section{Introduction}
\paragraph{Motivation.}
OSS capture a powerful capability: make \emph{exactly-one} valid signature and then render any further signing infeasible. This single-use authenticity primitive cleanly abstracts (i) deterministic finality (each height signs once), (ii) quantum money (mint once, then unforgeable), and (iii) trusted-setup-free SNARK parameters (derive a CRS and then provably erase toxic waste). Yet today’s OSSs require quantum unclonability; TEEs offer a practical path but single-enclave designs reduce the guarantee to “trust this one box forever”.

\paragraph{Our approach.}
\prot{} lifts OSS to an \emph{honest-minority} setting by distributing the signing key across independent enclaves using a threshold DKG. The system produces one threshold signature on a frozen message and then aggregates per-enclave certified-deletion attestations bound to the session. The exact-one property reduces to the infeasibility of recovering a deleted threshold share from \emph{at least one} honest enclave, plus freshness/anti-replay for attestations.

\paragraph{Contributions.}
\begin{itemize}[leftmargin=*,itemsep=0.25em,topsep=0.25em]
  \item A formalization of certified deletion and one-shot signing in a remote-attestation model with explicit freshness and context binding.
  \item \prot{}: a threshold-in-TEE protocol that yields \emph{exactly one} threshold signature and a set of deletion attestations; security is additive across heterogeneous TEEs.
  \item A pluggable attestation mechanism: TEE RA today; cryptoeconomic attestations; future quantum erasure attestations---preserving the OSS API.
  \item Application sketches for (i) deterministic finality, (ii) quantum-money-style tokens, and (iii) de-facto ceremony-free CRS derivations.
  \item A discussion of liveness under abort, anti-replay, rollback resistance, and heterogeneity as defense-in-depth.
\end{itemize}

\section{Background and Model}
\subsection{One-shot signatures in brief}
An \oss{} scheme exposes $(\mathsf{Setup},\mathsf{KeyGen},\mathsf{SignOnce},\mathsf{Verify})$ with the property that for any keypair, at most one signature on at most one message is computationally feasible. Security is captured by a game where the adversary, after arbitrary queries \emph{except} a second signing, fails to produce two distinct valid signatures or one valid signature after certified deletion.

\subsection{Threshold signatures \cFROST{}}
We assume a Schnorr-style $t$-of-$n$ threshold signature with a secure DKG (e.g., \FROST{}). Parties hold additive shares $\{sk_i\}$ with public key $pk$, and interactive signing produces $\sigma$ on message $m$. Unforgeability holds if fewer than $t$ shares leak and nonces are not reused.

\subsection{TEE trust and remote attestation}
Each party $P_i$ hosts an enclave $E_i$ implementing \prot{}. We assume:
\begin{itemize}[leftmargin=*,itemsep=0.25em]
  \item \textbf{Code identity}: attestation binds a measurement (\emph{code hash}) and policy to outputs.
  \item \textbf{Sealed state semantics}: used only pre-signing to persist the DKG result across a crash.
  \item \textbf{Freshness/anti-replay}: a monotonic epoch is available (hardware counter or append-only log) and is bound into attestations.
  \item \textbf{Deletion API}: an enclave can make shares unrecoverable (\emph{zeroization}) and prove the transition with attestation carrying auxiliary data.
\end{itemize}
We \emph{do not} assume perfect side-channel resistance or that all rollback vectors are impossible; instead we bind acceptance to freshness predicates and a one-shot latch.

\subsection{Adversary and network}
The network is asynchronous with eventual delivery. The adversary may statically corrupt up to $f$ enclaves and their hosts and is rushing. We target $t=n$ for strongest one-shot semantics; extensions to $t<n$ are discussed in \S\ref{sec:discussion}.

\section{\prot{} Protocol}\label{sec:protocol}

\begin{figure}[!htbp]
\centering
\begin{tikzpicture}[
  x=2.0cm,y=0.9cm,>=Stealth,
  every node/.style={font=\scriptsize},
  msg/.style={->,line width=0.4pt,shorten >=1pt,shorten <=1pt},
  lifeline/.style={densely dashed,line width=0.4pt},
  ann/.style={anchor=west,fill=white,inner sep=1.5pt,rounded corners=1pt,text width=6.2cm}
]
  % Column labels (kept separate from lifeline anchors)
  \node[align=center] (C_lbl)  at (0,0)   {Coordinator\\$C$};
  \node[align=center] (E1_lbl) at (2,0)   {$E_1$};
  \node[align=center] (Ed_lbl) at (3.5,0) {$\cdots$};
  \node[align=center] (En_lbl) at (5,0)   {$E_n$};

  % Lifeline anchors start below labels to avoid overlap
  \coordinate (C)  at (0,-0.8);
  \coordinate (E1) at (2,-0.8);
  \coordinate (Ed) at (3.5,-0.8);
  \coordinate (En) at (5,-0.8);

  % Lifelines
  \draw[lifeline] (C)  -- +(0,-9.8);
  \draw[lifeline] (E1) -- +(0,-9.8);
  \draw[lifeline] (Ed) -- +(0,-9.8);
  \draw[lifeline] (En) -- +(0,-9.8);

  % LEFT-MARGIN ANNOTATIONS (white boxes) to avoid any overlap with arrows
  \node[ann] at (-0.9,-1.0) {JOIN / RA$^{(\mathrm{JOIN})}$ (attested channels; $\mathsf{sid}$ fixed)};
  \node[ann] at (-0.9,-2.8) {In-enclave DKG (Schnorr / FROST) and RA$_\mathrm{DKG}$};
  \node[ann] at (-0.9,-5.0) {Commit $m^{\star}$ for $\mathsf{sid}$};
  \node[ann] at (-0.9,-6.2) {Threshold sign};
  \node[ann] at (-0.9,-8.2) {Delete \& RA$_\mathrm{DEL}$ (post-output)};
  \node[ann] at (-0.9,-9.8) {Verifier: check $\sigma^{\star}$ and $k$ fresh RA$_\mathrm{DEL}$ with prior RA$_\mathrm{DKG}$.};

  % 1) JOIN / RA_0
  \draw[msg] ($(E1)+(0,-1.2)$) -- node[above,sloped,near start]{$\RA(\mathsf{sid},\mathrm{JOIN},\mathsf{eid}_1)$} ($(C)+(0,-1.2)$);
  \draw[msg] ($(En)+(0,-1.5)$) -- node[above,sloped,near start]{$\RA(\mathsf{sid},\mathrm{JOIN},\mathsf{eid}_n)$} ($(C)+(0,-1.5)$);

  % 2) DKG (peer-to-peer) + RA_DKG
  \draw[<->,densely dotted,line width=0.4pt] ($(E1)+(0,-2.8)$) -- node[above]{shares/commitments} ($(Ed)+(0,-2.8)$);
  \draw[<->,densely dotted,line width=0.4pt] ($(Ed)+(0,-3.1)$) -- ($(En)+(0,-3.1)$);
  \draw[msg] ($(E1)+(0,-3.4)$) -- node[above,sloped,near start]{$\RA(\mathsf{sid},\mathrm{DKG},\mathsf{eid}_1,pk)$} ($(C)+(0,-3.4)$);
  \draw[msg] ($(En)+(0,-3.7)$) -- node[above,sloped,near start]{$\RA(\mathsf{sid},\mathrm{DKG},\mathsf{eid}_n,pk)$} ($(C)+(0,-3.7)$);

  % 3) Commit (freeze message for this sid)
  \draw[msg] ($(C)+(0,-4.8)$) -- node[above,sloped]{broadcast $(m^{\star},\mathsf{sid})$} ($(E1)+(0,-4.8)$);
  \draw[msg] ($(E1)+(0,-5.1)$) -- node[above,sloped]{broadcast $(m^{\star},\mathsf{sid})$} ($(En)+(0,-5.1)$);

  % 4) Sign (partials to aggregate)
  \draw[msg] ($(E1)+(0,-5.9)$) -- node[above,sloped,near start]{$\sigma_1$} ($(C)+(0,-5.9)$);
  \draw[msg] ($(En)+(0,-6.2)$) -- node[above,sloped,near start]{$\sigma_n$} ($(C)+(0,-6.2)$);
  \draw[msg] ($(C)+(0,-6.6)$) -- node[above,sloped]{publish $\sigma^{\star}$} ($(E1)+(0,-6.6)$);
  \draw[msg] ($(C)+(0,-6.9)$) -- node[above,sloped]{publish $\sigma^{\star}$} ($(En)+(0,-6.9)$);

  % 5) Certified deletion & RA_DEL
  \draw[msg] ($(E1)+(0,-8.1)$) -- node[above,sloped,near start]{$\RA(\mathsf{sid},\mathrm{DEL},\mathsf{eid}_1,pk,m^{\star},\sigma^{\star})$} ($(C)+(0,-8.1)$);
  \draw[msg] ($(En)+(0,-8.4)$) -- node[above,sloped,near start]{$\RA(\mathsf{sid},\mathrm{DEL},\mathsf{eid}_n,pk,m^{\star},\sigma^{\star})$} ($(C)+(0,-8.4)$);
\end{tikzpicture}
\caption{QuanTEEum message flow: RA$^{(\mathrm{JOIN})}$ (JOIN), RA$_\mathrm{DKG}$ (bind $pk$), Commit $m^{\star}$, Sign, RA$_\mathrm{DEL}$ (delete).}
\label{fig:flow}
\end{figure}

\paragraph{Roles.}
Parties $\{P_1,\dots,P_n\}$ run enclaves $\{E_1,\dots,E_n\}$.
A (rotating) coordinator $C$ orchestrates rounds but learns no secrets.
All protocol traffic (JOIN, DKG, Commit, Sign, Delete) is carried over
\emph{attested secure channels} (e.g., RA–TLS) whose channel binding includes an
ephemeral enclave public key $\mathsf{eid}$ attested by the enclave.

\paragraph{Session binding.}
We use DKG-first. A session identifier $\mathsf{sid}$ is derived
\[
  \mathsf{sid} \gets H(\mathsf{suite}\,\|\,\mathsf{policy\_hash}\,\|\,\mathsf{nonce}),
\]
and is embedded in all protocol messages and in the attestation \emph{reportdata}.
Here $\mathsf{nonce}$ is a fresh 128-bit value chosen by $C$ at JOIN.
The designated message $m^{\star}$ is \emph{frozen later} by a Commit step
(after DKG and before signing) and appears in the deletion attestation.

\paragraph{Parameters.}
\begin{itemize}[leftmargin=*,itemsep=0.25em]
  \item $\mathsf{suite}$: cryptographic suite identifier (curve/group, hash, domain separators, transcript encoding, threshold-signing variant).
  \item $\mathsf{policy}$: canonical verifier policy (e.g., $n,t$, minimum $\mathsf{DEL}$ attestations $k$, vendor/diversity constraints, RA roots, allowed measurements, freshness-oracle details).
  \item $\mathsf{policy\_hash} := H(\mathsf{policy})$ (committed by $\mathsf{sid}$).
  \item $\mathsf{nonce}$: 128-bit coordinator nonce ensuring $\mathsf{sid}$ uniqueness.
  \item $\mathsf{eid}$: enclave’s attested ephemeral DH/public key (per session), also used to bind the RA–TLS channel.
\end{itemize}

\paragraph{Attestation reportdata (aux).}
We use \emph{phases} $\mathsf{phase}\in\{\mathsf{JOIN},\mathsf{DKG},\mathsf{DEL}\}$ in the reportdata; no counters/timestamps.
All encodings are length-delimited and unambiguous.
\begin{align*}
  \text{RA}^{(\mathrm{JOIN})}\!:\ & \mathsf{aux} = (\mathsf{sid},\ \mathsf{phase}=\mathsf{JOIN},\ \mathsf{eid}) \\
  \text{RA}^{(\mathsf{DKG})}\!:\ & \mathsf{aux} = (\mathsf{sid},\ \mathsf{phase}=\mathsf{DKG},\ \mathsf{eid},\ pk) \\
  \text{RA}^{(\mathrm{DEL})}\!:\ & \mathsf{aux} = (\mathsf{sid},\ \mathsf{phase}=\mathsf{DEL},\ \mathsf{eid},\ pk,\ m^{\star},\ \sigma^{\star})
\end{align*}
Intuition: RA$^{(\mathrm{JOIN})}$ gates participation and binds $\mathsf{eid}$ to $\mathsf{sid}$; RA$^{(\mathsf{dkg})}$ binds the DKG result $pk$ to $\mathsf{sid}$ and $\mathsf{eid}$;
RA$^{(\mathrm{DEL})}$ certifies deletion \emph{after} producing the unique output $(m^{\star},\sigma^{\star})$.

\paragraph{Freshness and anti-replay.}
We rely on an append-only \emph{freshness oracle} (e.g., transparency log or notary quorum) that stores
entries keyed by $(\mathsf{sid},\mathsf{phase},\mathsf{eid}) \mapsto \text{digest(quote)}$ and enforces:
(i) \emph{uniqueness}: at most one entry per key; and
(ii) \emph{order}: for each $(\mathsf{sid},\mathsf{eid})$, $\mathsf{DKG}$ must precede $\mathsf{DEL}$ (JOIN optional).
Verifiers reject any $\mathsf{DEL}$ without a prior $\mathsf{DKG}$ for the same $(\mathsf{sid},\mathsf{eid})$.

\paragraph{Policy checks:}
\begin{description}
  \item[\textbf{JOIN:}] $C$ broadcasts $(\mathsf{suite},\mathsf{policy},\mathsf{nonce},\mathsf{sid})$.
  Each enclave locally admits $\mathsf{policy}$ (e.g., allowlist or operator-signed), then emits RA$^{(\mathrm{JOIN})}$.
  $C$ proceeds only with enclaves whose RA$^{(\mathrm{JOIN})}$ verifies and whose $\mathsf{sid}$ matches.
  \item[\textbf{DKG:}] Enclaves run DKG over RA-bound channels; after DKG each emits RA$^{(\mathsf{dkg})}$ with $(\mathsf{sid},\mathsf{DKG},\mathsf{eid},pk)$.
  $C$ ensures all RA$^{(\mathsf{dkg})}$ bind to the same $(\mathsf{sid},pk)$.
  \item[\textbf{Verification:}] An external verifier recomputes $\mathsf{policy\_hash}$ from its configured $\mathsf{policy}$,
  checks that $\mathsf{sid}$ commits to it, and accepts iff:
  \begin{enumerate}
    \item[(a)] $\mathsf{Verify}(pk,m^{\star},\sigma^{\star})=1$,
    \item[(b)] there are at least $k$ valid RA$^{(\mathrm{DEL})}$ with distinct $\mathsf{eid}$ satisfying diversity constraints, and
    \item[(c)] each such $\mathsf{eid}$ has a prior RA$^{(\mathsf{DKG})}$ in the freshness oracle for the same $(\mathsf{sid},pk)$.
  \end{enumerate}
\end{description}

\subsection*{Interfaces and notation}
\begin{itemize}[leftmargin=*,itemsep=0.25em]
  \item $\textsf{RA.GenQuote}(\mathsf{aux}) \rightarrow \mathsf{RA}$:
  produce a vendor-signed attestation over the enclave measurement and the byte string $\mathsf{aux}$.

  \item $\textsf{RA.Verify}(\mathsf{RA};\ \textsf{allow\_meas},\ \textsf{roots}) \in \{0,1\}$:
  verify signature under trusted RA roots and check the code measurement against the allowlist.

  \item $\textsf{Oracle.Append}(\mathsf{sid},\mathsf{phase},\mathsf{eid},\mathsf{RA})
  \in \{\mathsf{ok},\mathsf{dup},\mathsf{order\_err}\}$:
  append the quote’s digest to the append-only freshness oracle keyed by $(\mathsf{sid},\mathsf{phase},\mathsf{eid})$;
  returns $\mathsf{dup}$ on a repeat key and $\mathsf{order\_err}$ if $\mathsf{DEL}$ lacks a prior $\mathsf{DKG}$.

  \item $\textsf{Latch}(\sid,m^{\star})$:
  bind $m^{\star}$ for this session inside the enclave; subsequent signing attempts under the same $\sid$ abort.

  \item $\textsf{Del}()$:
  irrecoverably zeroize the in-enclave key material and nonces (invoked before RA$^{(\mathrm{DEL})}$).
\end{itemize}

\subsection{Setup and DKG}
\begin{enumerate}[leftmargin=*,itemsep=0.25em]
  \item \textbf{Roster selection (policy-based).} The coordinator $C$ selects a set of enclaves $\{E_i\}$ that satisfy $\mathsf{policy}$ (diversity, allowlisted measurements, RA roots).
  \item \textbf{JOIN.} Each invited $E_i$ establishes an RA–bound secure channel (RA–TLS) with ephemeral $\mathsf{eid}_i$ and emits
        RA$^{(\mathrm{JOIN})}$ with $\mathsf{aux}=(\mathsf{sid},\mathsf{JOIN},\mathsf{eid}_i)$.
  \item \textbf{Peer vetting of JOIN.} $C$ distributes the set of RA$^{(\mathrm{JOIN})}$ quotes to all $E_i$.
        Each $E_i$ verifies that all quotes validate under trusted roots, share the same $\mathsf{sid}$,
        and that the \emph{set} of participants satisfies $\mathsf{policy}$. Enclaves abort if checks fail.
  \item \textbf{DKG.} The enclaves run a Schnorr-threshold DKG (e.g., \FROST{}) entirely in\mbox{-}enclave over the attested channels,
        obtaining additive shares $\{sk_i\}$ and group public key $pk$. Shares remain only in enclave memory; optionally seal $sk_i$ until Commit/Sign.
  \item \textbf{Bind DKG result.} Each $E_i$ emits RA$^{(\mathsf{DKG})}$ with $\mathsf{aux}=(\mathsf{sid},\mathsf{DKG},\mathsf{eid}_i,pk)$;
        $C$ proceeds only if all quotes verify and bind to the same $(\mathsf{sid},pk)$, and appends them to the freshness oracle.
\end{enumerate}

\begin{algorithm}[!htbp]
\caption{\prot{}: \emph{SetupAndDKG} (inside enclave $E_i$)}
\label{alg:setup}
\begin{small}
\begin{algorithmic}[1]
\State Receive roster invitation and $(\mathsf{suite},\mathsf{policy},\mathsf{nonce},\mathsf{sid})$ from $C$.
\State Measure code $\mathsf{meas}$; generate ephemeral $\mathsf{eid}_i$; establish RA--TLS channel bound to $\mathsf{eid}_i$.
\State $\mathsf{RA}^{(\mathrm{JOIN})}_i \gets \textsf{RA.GenQuote}\big((\mathsf{sid},\mathsf{JOIN},\mathsf{eid}_i)\big)$; send to $C$.
\State Receive the set $\{\mathsf{RA}^{(\mathrm{JOIN})}_j\}_j$ for all invited enclaves from $C$; for each, run \textsf{RA.Verify} and check same $\mathsf{sid}$ and that the set satisfies $\mathsf{policy}$; abort on failure.
\State Run in\mbox{-}enclave Schnorr-threshold DKG (e.g., \FROST{}) $\rightarrow$ local share $sk_i$ and group $pk$.
\State Optionally \emph{seal} $sk_i$ until Commit/Sign; never export $sk_i$.
\State $\mathsf{RA}^{(\mathsf{DKG})}_i \gets \textsf{RA.GenQuote}\big((\mathsf{sid},\mathsf{DKG},\mathsf{eid}_i,pk)\big)$; send to $C$.
\State $\textsf{Oracle.Append}(\mathsf{sid},\mathsf{DKG},\mathsf{eid}_i,\mathsf{RA}^{(\mathsf{DKG})}_i)$.
\State \textbf{return} $pk$ (to the application/coordinator); \textbf{never} reveal $sk_i$.
\end{algorithmic}
\end{small}
\end{algorithm}

\subsection{Single-signing phase}
\begin{enumerate}
  \item \textbf{Commit.} $C$ chooses $m^{\star}$, derives $\mathsf{sid}$, broadcasts $(m^{\star},\mathsf{sid})$.
  \item \textbf{Latch.} Each $E_i$ verifies policy, binds $(m^{\star},\mathsf{sid})$ to its local one-shot latch, and bumps a monotonic epoch $ctr \leftarrow ctr{+}1$.
  \item \textbf{Sign.} Enclaves execute threshold signing (e.g., \FROST{}) on $m^{\star}$, producing partial signatures $\sigma_i$; $C$ aggregates to $\sigma^{\star}$.
\end{enumerate}

\begin{algorithm}[!htbp]
\caption{\prot{}: \emph{SingleSign} on designated message $m^{\star}$}
\label{alg:sign}
\begin{small}
\begin{algorithmic}[1]
\State Coordinator $C$ derives $\mathsf{sid} \gets H(\mathsf{suite}\,\|\,\mathsf{policy}\,\|\,\mathsf{meas}\,\|\,m^{\star}\,\|\,\mathsf{nonce})$.
\State $C$ broadcasts $(m^{\star},\mathsf{sid})$.
\For{each enclave $E_i$}
  \State Verify policy; bind $(m^{\star},\mathsf{sid})$ to one\mbox{-}shot latch; bump $ctr \leftarrow ctr{+}1$.
  \State Run \FROST{} partial signing on $m^{\star}$ to get $\sigma_i$; send to $C$.
\EndFor
\State $C$ aggregates $\{\sigma_i\}$ into $\sigma^{\star}$; publish $\sigma^{\star}$.
\State \textbf{return} $\sigma^{\star}$.
\end{algorithmic}
\end{small}
\end{algorithm}

\subsection{Certified deletion and verification}\label{sec:verify}
\begin{enumerate}
  \item \textbf{Delete \& attest.} Each $E_i$ executes \textsf{Del}(), records post-delete epoch $ctr'$, and generates $\RA_i^{(\mathrm{del})}$ over auxiliary data
  \[
    \textsf{aux}_i := (\mathsf{sid}\,\|\,m^{\star}\,\|\,\sigma^{\star}\,\|\,pk\,\|\,ctr').
  \]
  \item \textbf{Accept.} Verifier accepts iff (i) $\mathsf{Verify}(pk,m^{\star},\sigma^{\star})=1$, (ii) for a threshold $k$ (typically $k{=}n$), all $\{\RA_i^{(\mathrm{del})}\}$ validate under vendor roots and pass \textsf{Fresh}, and (iii) measurements and policy match the expected enclave code for \prot{}.
\end{enumerate}

\begin{algorithm}[!htbp]
\caption{\prot{}: \emph{DeleteAndVerify}}
\label{alg:delete-verify}
\begin{small}
\begin{algorithmic}[1]
\For{each enclave $E_i$}
  \State \textsf{Del}(): zeroize $sk_i$ and nonces; bump $ctr' \leftarrow ctr{+}1$.
  \State $\textsf{aux}_i \gets (\mathsf{sid}\,\|\,m^{\star}\,\|\,\sigma^{\star}\,\|\,pk\,\|\,ctr')$.
  \State $\RA_i^{(\mathrm{del})} \gets \textsf{RA.GenQuote}(\textsf{aux}_i)$; send to verifier.
\EndFor
\State \textbf{Accept} iff $\mathsf{Verify}(pk,m^{\star},\sigma^{\star})=1$ and at least $k$ quotes validate:
\State \hspace{1.2em}$\forall i\in Q:\ \textsf{VerifyRA}(\RA_i^{(\mathrm{del})})\wedge \textsf{Fresh}(\RA_i^{(\mathrm{del})},\mathsf{sid})\wedge \mathsf{meas}{=}\mathsf{expected}$.
\end{algorithmic}
\end{small}
\end{algorithm}

\subsection{Exact-one property}
The latch enforces a one-way state transition: any subsequent signing attempt with the same $\sid$ or with a new $\sid$ on the same enclave instance must verify $ctr$ strictly increases; \prot{} refuses pre-nonce sampling if either (a) \emph{post-delete} is set, or (b) the expected epoch monotonicity fails, preventing rollback-based nonce or key re-use.

\section{Security}\label{sec:security}
We sketch the core arguments; full proofs follow the standard game-hopping template with RA-oracle idealization.

\paragraph{Safety: one-shot unforgeability.}
\begin{theorem}[One-shot from threshold-in-TEE]\label{thm:one-shot}
Assume (i) the underlying threshold signature is unforgeable, (ii) at least one enclave is honest and transitions to post-delete state after producing $\sigma^{\star}$, (iii) \textsf{Fresh} prevents replay/rollback of pre-delete states, and (iv) vendor RA is unforgeable under the stated trust roots. Then producing two distinct valid signatures $(\sigma_1,\sigma_2)$ for the same $pk$ in session $\mathsf{sid}$ (on either same or distinct messages) is infeasible for PPT adversaries.
\end{theorem}

\begin{proof}[Proof sketch]
Suppose two signatures exist. If either is produced without $t$ valid shares, we break threshold unforgeability. Otherwise, at least $t$ shares were live at each signing. Because at least one honest enclave deleted its share and emitted $\RA^{(\mathrm{del})}$ bound to $(\mathsf{sid},m^{\star},\sigma^{\star})$, the only routes to a second signature are: (A) forge RA to claim deletion without deleting (contradicts RA unforgeability); (B) roll back the honest enclave to pre-delete (contradicts \textsf{Fresh}); (C) extract the honest enclave's share pre-delete (outside model unless SGX breaks); or (D) compromise enough enclaves across heterogeneous vendors (violates honest-minority).
\end{proof}

\paragraph{Liveness.}
With $t=n$ the protocol requires all enclaves to participate; a crashed or aborting enclave prevents progress. We adopt a bounded timeout: if signing fails, $C$ abandons $\sid$ and re-instantiates with fresh enclaves. In deployments desiring partial progress, \prot{} supports $t<n$ with two caveats: (i) erase attestations must reach $k\!\ge\!t$; (ii) the exact-one property is now conditioned on at least one of the $k$ attesting enclaves being honest.

\paragraph{Additive security via heterogeneity.}
If attestations are independent across vendors/geographies, the minimum attack cost is approximately the sum of per-enclave compromise costs (or, more conservatively, the minimum of all subsets of size $t$). We recommend explicit heterogeneity policies (e.g., “at least two vendors and three physical operators”).

\paragraph{Freshness and anti-replay.}
We require verifiers to check: (i) an enclave-specific monotonic counter $ctr'$ strictly increases across quotes, and (ii) the quote timestamp is recent, or (iii) an append-only public log includes the tuple $(\mathsf{sid},pk,m^{\star},\sigma^{\star},\mathsf{meas},ctr')$ before acceptance. Any quote with stale $ctr'$ or mismatched measurement is rejected.

\section{Applications}\label{sec:apps}
\subsection{Deterministic finality via one-shot chains}
For each height $h$, derive $\mathsf{sid}_h := H(h\,\|\,\textsf{policy}\,\|\,\cdots)$ and fix $m_h^{\star}$ to the block header. Validators (or a specialized \emph{finality committee}) host enclaves that run \prot{} to produce $\sigma_h^{\star}$ and deletion attestations. A block is \emph{final} when $(\sigma_h^{\star},\{\RA_i\})$ verifies. Safety reduces to Theorem~\ref{thm:one-shot}; liveness reduces to committee availability. Coordinator rotation prevents a single orchestrator from stalling progress.

\subsection{Quantum-money-flavored tokens}
Minting a token corresponds to running \prot{} with $m^{\star}$ encoding the serial and policy. Transfer can be modeled by \emph{re-minting} with a new serial bound to the recipient (or by embedding verification keys in a ledger that checks the one-shot predicate on spend). \prot{} supplies a classical OSS now; the same API can be “swapped” for quantum OSS later without redesign.

\subsection{De-facto ceremony-free CRS}
To derive a one-circuit CRS, set $m^{\star}$ to the transcript-to-be-signed, generate $\sigma^{\star}$, then erase all key material and nonces, attesting deletion. While this is not a plain-model proof of toxic-waste non-existence, it yields an auditable deletion trail with honest-minority robustness and heterogeneity, improving over single-operator ceremonies.

\section{Discussion and Future Work}\label{sec:discussion}
\paragraph{Why $t\!=\!n$ first?}
It maximizes the exact-one semantics and simplifies acceptance (\emph{all} attest). Generalizing to $t<n$ is straightforward mechanically but shifts the trust statement to “among the $k\!\ge\!t$ attesters, at least one honest enclave deleted.”

\paragraph{Nonce discipline.}
Nonce misuse is fatal in Schnorr. All nonce generation and aggregation must occur in-enclave; nonces are zeroized alongside shares and bound to $\sid$.

\paragraph{Rollback channels.}
Hardware monotonic counters are ideal but scarce; when unavailable, anchor \textsf{Fresh} in an append-only public log (e.g., consensus chain) and/or a replicated monotonicity oracle.

\paragraph{Cryptoeconomic attestations.}
Replace RA with bonded claims: each operator escrows collateral and signs a deletion statement $(\sid,m^{*},\sigma^{*})$ under a registered key; slashing conditions penalize equivocation or reuse. This yields weaker, but composable, guarantees and can be \emph{combined} with RA for stronger additivity.

\paragraph{Heterogeneity policy.}
Enforce at least two TEE vendors, distinct cloud providers, and distinct administrative domains. Acceptance SHOULD require a diversity predicate (e.g., vendor quorum).

\paragraph{Upgrade to quantum OSS.}
Once practical, swap the attestation mechanism for a quantum-certified deletion proof with the same acceptance predicate. Because \prot{} already binds $(\mathsf{sid},m^{\star},\sigma^{\star},pk)$ into attestations, the application layer remains unchanged.

\section{Conclusion}
\prot{} offers a deployable path to one-shot capabilities by composing threshold signatures with certified deletion inside heterogeneous TEEs. The exact-one property becomes an honest-minority statement with additive security across independent attestations. The same interface smoothly upgrades to future quantum OSS, enabling deterministic finality, quantum-money-like assets, and auditable substitutes for toxic-waste ceremonies.

\bibliographystyle{splncs04}
\bibliography{refs}
\end{document}